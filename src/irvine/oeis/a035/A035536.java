package irvine.oeis.a035;
// Generated by gen_seq4.pl A035536 0 0  at (DATE)
// DO NOT EDIT here!
/* 
    (maple), alois heinz:
    b := proc(n, i, c) option remember; `if`(n=0,
      `if`(c=0, 1, 0), `if`(i<1, 0, b(n, i-1, c)+
       b(n-i, min(n-i, i), c+[0, 1, -1][1+irem(i, 3)])))
    end:
    seq(b(n,n, 0), n=0..32);
__DATA__
1, 0, 0, 2, 0, 0, 6, 0, 0, 14, 0, 0, 32, 0, 0, 66, 0, 0, 134, 0, 0, 256, 0, 0
, 480, 0, 0, 868, 0, 0, 1540, 0, 0, 2664, 0, 0, 4536, 0, 0, 7574, 0, 0
, 12474, 0, 0, 20234, 0, 0, 32428, 0, 0, 51324, 0, 0, 80388, 0, 0, 124582
, 0, 0, 191310, 0, 0, 291114, 0, 0, 439394, 0, 0, 657936, 0, 0
*/

import irvine.math.MemoryFunctionInt3;
import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A035536 Number of partitions of n with equal number of parts congruent to each of 1 and 2 (mod 3).
 * @author Georg Fischer
 */
public class A035536 extends MemoryFunctionInt3<Z> implements Sequence {

  protected final int[] mModules; // which combination of elements to select
  protected final int mImod; // take i mod this number
  protected int mN; // index of next term
  
  /** Construct with default parameters. */
  public A035536() {
    this(0, 3, 0, 1, -1);
  }
    
  /** 
   * Construct the sequence. 
   * @param offset index of first term
   * @param imod take i mod this number
   * @param modules vector of valid values
   */
  public A035536(final int offset, final int imod, final int... modules) {
    mImod = imod;
    mModules = modules;
    mN = offset - 1;
  }
    
  /**
   * Recursively evaluate all partitions and accumulate information for the condition
   * @param n number to be partitioned
   * @param i nesting level
   * @param t first accumulator
   * @return number of partitions of n with this condition 
   */
  @Override
  protected Z compute(final int n, final int i, final int t) {
    final Z result;
    if (n == 0) {
      result = t == 0 ? Z.ONE : Z.ZERO;
    } else {
      if (i < 1) {
        result = Z.ZERO;
      } else {
        final int ni = n - i;
        result = get(n, i - 1, t)
          .add(get(ni, Math.min(ni, i), t + mModules[i % mImod]));
      }
    }
    return result;
  }
  
  /**
   * Compute the next term of the sequence
   * @return a specific number of partitions
   */
  @Override
  public Z next() {
    ++mN;
    return get(mN, mN, 0);
  }

  /**
   * Compute a number of terms for A035536
   * @param args number of terms
   */
  public static void main(final String[] args) {
    int termNo = 64;
    final A035536 seq = new A035536();
    if (args.length > 0) {
      try {
        termNo = Integer.parseInt(args[0]);
      } catch (final Exception exc) { // ignore
      }
    }
    for (int index = 0; index < termNo; ++index) {
      System.out.println(index + " " + seq.next());
    }
    System.out.println(seq.size() + " parameter sets remembered");
  }
}
